%        File: tls.tex
%     Created: ä¸€ 11 21 03:00 ä¸‹åˆ 2016 C
% Last Change: ä¸€ 11 21 03:00 ä¸‹åˆ 2016 C
%
\documentclass[a4paper]{ctexart}

\title{\heiti{}TLSåè®®1.2å­¦ä¹ æœ­è®°}
\author{\kaishu Cuiting Shi}
\date{\today{}}

\bibliographystyle{plain}

\usepackage[a4paper, centering, scale=0.8]{geometry}
\usepackage[nottoc]{tocbibind}
\usepackage[]{color}
\usepackage{listings}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{mauve}{rgb}{0.58,0,0.72}
\definecolor{orange}{rgb}{0.92, 0.72, 0.15}
\lstdefinelanguage{golang} {
  classoffset=0,
  morekeywords={ type, struct, error, int, int8, int16, int32, int64, byte, string, bool, 
    uint, uint8, uint16, uint32, uint64, nil, func, var, map
  },  
  keywordstyle=\color{blue},
  classoffset=1,
  morekeywords={ fallthrough, go, chan, break,  default, range,
    switch, select, case, if, else, for, while, do, in, import, return, 
  }, 
  keywordstyle=\color{orange},
  classoffset=2,
  morekeywords={ len, copy, panic, make },
  keywordstyle=\color{red},
  classoffset=0,
  sensitive=false,
  morecomment=[l][\color{dkgreen}]{//},
  morecomment=[s][\color{dkgreen}]{/*}{*/},
  morestring=[b]``, 
}
\lstset{
  language=golang,
  morecomment=[s][\color{dkgreen}]{/*}{*/},
  stringstyle=\color{mauve},
  aboveskip=3mm,
  belowskip=3mm,
  columns=flexible,
  breaklines=true,
  basicstyle={\small \ttfamily}, 
  numbers=left,
  numberstyle={\tiny}
}

\begin{document}

\maketitle{}
\begin{abstract}
  è¿™æ˜¯ä¸€ç¯‡å…³äºTLSåè®®1.2çš„å­¦ä¹ ç¬”è®°
\end{abstract}
\tableofcontents{}

\section{Introduction}
TLSåè®®æ˜¯åŸºäºSSL 3.0 åè®®çš„ï¼ŒäºŒè€…ä¹‹é—´çš„å·®å¼‚å¹¶ä¸æ˜¯å¾ˆæ˜æ˜¾.
TLSåè®®çš„ä¸»è¦ç›®çš„æ˜¯ä¸ºä¸¤ä¸ªé€šä¿¡è¿›ç¨‹æä¾›éšç§æ€§å³æ•°æ®å®Œæ•´æ€§. è¯¥åè®®æœ‰ä¸¤å±‚: TLS Record Protocol å’Œ TLS Handshake Protocol.
TLS Record Protocol æ˜¯TLSçš„åè®®çš„æœ€åº•å±‚ï¼Œä½†æ˜¯æ˜¯ä½äºä¸€äº›ä¼ è¾“åè®®çš„ä¸Šå±‚çš„(æ¯”å¦‚TCP). 
TLS Record Protocol ä¸ºè¿æ¥æä¾›äº†å®‰å…¨ä¿éšœï¼Œè¯¥è¿æ¥å…·æœ‰ä¸¤ä¸ªä¸»è¦ç‰¹ç‚¹:

\begin{itemize}
    \zihao{-5}\kaishu 
  \item è¿æ¥å…·æœ‰éšç§æ€§ã€‚å…¶ä¸­é‡‡ç”¨äº†å¯¹ç§°åŠ å¯†å¯¹æ•°æ®è¿›è¡ŒåŠ å¯†(æ¯”å¦‚AES, RC4 ç­‰å¾…). æ¯æ¬¡è¿æ¥éƒ½ä¼šç”Ÿæˆæ–°çš„å¯¹ç§°åŠ å¯†çš„ç§˜é’¥ï¼Œ
    è¯¥ç§˜é’¥æ˜¯åŸºäºTLS Handshake Protocol ç”Ÿæˆçš„ä¸€ä¸ªsecret ç”Ÿæˆçš„(å½“ç„¶ï¼Œä¹Ÿå¯ä»¥é‡‡ç”¨é™¤äº†TLS Handshake Protocolä¹‹å¤–çš„å…¶å®ƒåè®®è¿›è¡Œåå•†è·å–secret). 
    TLS Record Protocol å…¶å®ä¹Ÿå¯ä»¥ä¸é€‚ç”¨åŠ å¯†, è€Œæ˜¯ç›´æ¥ä¼ è¾“æ˜æ–‡æ•°æ®.
  \item ç¬¬äºŒä¸ªç‰¹ç‚¹æ˜¯è¿æ¥æ˜¯å¯é çš„. æ¶ˆæ¯çš„ä¼ è¾“åŒ…æ‹¬ä½¿ç”¨a keyed MAC æ¥å¯¹æ¶ˆæ¯çš„å®Œæ•´æ€§è¿›è¡Œæ ¡éªŒ. å…¶ä¸­ï¼ŒMAC è®¡ç®—ä¼šé‡‡ç”¨ç±»ä¼¼äºSHA-1 çš„ secure hash functions.
    å½“ç„¶, TLS Record Protocol ä¹Ÿå¯ä»¥ä¸é€‚ç”¨MACï¼Œä½†æ˜¯åªä¼šåœ¨å¦‚ä¸‹åœºæ™¯ä¸­åº”ç”¨ -- å³å¦å¤–ä¸€ä¸ªåè®®ä»…ä»…æ˜¯æŠŠTLS Record Protocol å½“åšåå•†å®‰å…¨å‚æ•°çš„ä¼ è¾“å·¥å…·ğŸ˜‚.
\end{itemize}

å¥½å§ï¼Œå¤§å®¶ç»å¸¸æ˜¯ä½¿ç”¨TLS Record Protocol æ¥å°è£…å„ç§é«˜å±‚åè®®. æ¯”å¦‚ï¼Œ TLS Record Protocol å¯ä»¥ç”¨æ¥å°è£… TLS Handshake Protocol, ä»è€Œä½¿å¾—åœ¨application
protocol ä¼ è¾“æˆ–è€…æ¥æ”¶æ•°æ®çš„é¦–å­—èŠ‚ä¹‹å‰, ä¾¿å¯ä»¥å…è®¸server å’Œ client ç«¯è¿›è¡Œè®¤è¯å’Œåå•†åŠ å¯†ç®—æ³•ã€cryptographic keys. TLS Handshake protocol æä¾›çš„å®‰å…¨è¿æ¥
å…·æœ‰ä¸‹é¢ä¸‰ä¸ªåŸºæœ¬ç‰¹å¾: 

\begin{itemize}
    \zihao{-5}\kaishu 
  \item client æˆ–è€…server çš„èº«ä»½å¯ä»¥ä½¿ç”¨å…¬é’¥ã€crpytography (æ¯”å¦‚, RSA, DSA ç­‰ç­‰). è¯¥è®¤è¯æ˜¯å¯é€‰çš„, ä½†é€šå¸¸è‡³å°‘æœ‰ä¸€æ–¹æ˜¯è¦è¿›è¡Œè®¤è¯çš„.
  \item å¯¹äºå…±äº«çš„secretçš„åå•†è¿‡ç¨‹æ˜¯å®‰å…¨çš„
  \item åå•†è¿‡ç¨‹æ˜¯å¯é çš„, å› ä¸ºåªè¦æ”»å‡»è€…è¯•å›¾ä¿®æ”¹åå•†çš„ä¿¡æ¯ï¼Œé€šä¿¡çš„åŒæ–¹å¿…å®šä¼šè§‰å¯Ÿåˆ°çš„ã€‚
\end{itemize}

TLS æ˜¯ç‹¬ç«‹äºåº”ç”¨åè®®çš„ï¼Œé«˜å±‚çš„åè®®å¯ä»¥é€æ˜åœ°å»ºç«‹åœ¨TLSåè®®ä¸Šã€‚ç„¶è€Œï¼Œç”±äºTLS æ ‡å‡†å¹¶æ²¡æœ‰æŒ‡å®šprotocols åº”è¯¥å¦‚ä½•é€šè¿‡TLS æ¥å¢å¼ºå®‰å…¨æ€§,
è¿™ä½¿å¾—è®¾è®¡è€…ä»¥åŠè¿è¡Œåœ¨TLS ä¹‹ä¸Šçš„protocols çš„å®ç°å¿…é¡»å¾—è‡ªå·±è€ƒè™‘å¦‚ä½•Initiate TLS handshakingã€å¦‚ä½•è§£æauthentication certificates.

\subsection{TLSåè®®1.2 VS 1.1}
ç›¸æ¯”äºTLSåè®®1.1, TLSåè®®1.2 å…·æœ‰æ›´å¤§çš„çµæ´»æ€§ï¼Œæ”¹è¿›å¦‚ä¸‹:
\begin{description}
    \zihao{-5}\kaishu 
  \item[-] åŸå…ˆåœ¨ä¼ªéšæœºå‡½æ•°PRFä¸­æ‰€ä½¿ç”¨çš„ MD5/SHA-1 ç»„åˆè¢«æ›¿æ¢æˆäº† cipher-suite-specified PRFs
  \item[-] æ•°å­—ç­¾åå…ƒç´ ä¸­çš„MD5/SHA-1ç»„åˆè¢«æ›¿æ¢æˆå¤§è¡£çš„å“ˆå¸Œå‡½æ•°, å…ƒç´ ç°åœ¨å¯ä»¥å¢åŠ ä¸€ä¸ªfieldæ¥è‡´å‘½å“ˆå¸Œç®—æ³•
  \item[-] åœ¨å‘é€å®Œcertificate\_requestä¹‹å, å¦‚æœæ²¡æœ‰å¯ç”¨è¯ä¹¦çš„è¯ï¼Œclientså¿…é¡»å‘é€ç©ºçš„è¯ä¹¦åˆ—è¡¨
  \item[-] cipher suiteçš„å®ç°è€…å¿…é¡»å¾—å®ç°TLS\_RSA\_WITH\_AES\_128\_CBC\_SHA
  \item[-] cipher suites æ·»åŠ äº† HMAC-SHA256, ç§»é™¤æ‰äº† IDEA å’Œ DES
\end{description}


\section{TLSåè®®çš„ç›®çš„} \label{sec:goal}
TLSåè®®çš„ç›®çš„åœ¨äº:
\begin{enumerate}
    \zihao{-5}\kaishu 
  \item Crytographic security: åº”è¯¥ä½¿ç”¨TLS ä¸ºåŒæ–¹çš„é€šä¿¡å»ºç«‹èµ·å®‰å…¨è¿æ¥
  \item Interoperability: åœ¨ä¸çŸ¥é“å¯¹æ–¹çš„ä»£ç çš„æƒ…å†µä¸‹ï¼Œä¸åŒçš„ç¨‹åºå‘˜åœ¨ä»–ä»¬ç¼–å†™çš„åº”ç”¨ç¨‹åºä¸­éƒ½ä½¿ç”¨äº†TLS, 
    é‚£ä¹ˆè¿™äº›åº”ç”¨ç¨‹åºæ˜¯å¯ä»¥æˆåŠŸäº¤æ¢cryptographic parameters çš„.
  \item Extensibility: TLS çš„ç›®çš„åœ¨äºæä¾›ä¸€ç§æ–°çš„å…¬é’¥å’Œbulk encryption methods å¯ä»¥å¹¶å…¥çš„åè®®æ¡†æ¶ä¸­, 
    è¿™æ ·å¯ä»¥é¿å…å®ç°ä¸€ä¸ªå…¨æ–°çš„å®‰å…¨åº“çš„å¯èƒ½æ€§.
  \item Relative efficiency: ç”±äºCryptographic operationså¸¸å¸¸éå¸¸è€—è´¹CPU, ç‰¹åˆ«æ˜¯å…¶ä¸­çš„public key operations, ä¸ºæ­¤,
    TLS åè®®å¢åŠ äº†session caching scheme, ä»è€Œå¯ä»¥å‡å°‘ä»é›¶å¼€å§‹å»ºç«‹è¿æ¥çš„æ•°é‡.

\end{enumerate}


\section{Cryptographic Attributes}
æ€»å…±æœ‰äº”ç§cryptographic operations:
\begin{enumerate}
    \zihao{-5}\kaishu
  \item digital signing
  \item stream cipher encryption
  \item block cipher encryption
  \item authenticated encryption with additional data (AEAD) encryption
  \item public key encryption
\end{enumerate}
æ³¨æ„å¯¹ç§°åŠ å¯†ä¸»è¦æœ‰ä¸¤ç§æ¨¡å¼, ä¸€ç§æ˜¯åºåˆ—åŠ å¯†(äº¦ç§°ä¸ºæµåŠ å¯† strema cipher encryption), å¦å¤–ä¸€ç§æ˜¯åˆ†ç»„åŠ å¯†(å³block cipher encryption).

%\begin{lstlisting}[frame=single, stepnumber=5, firstnumber=25, caption={ TLS package ä¸­å¯¹äºnet.Connæ¥å£çš„å®ç°}]{/usr/local/Cellar/go/1.7/libexec/src/crypto/tls/conn.go}

%\end{lstlisting}

\lstinputlisting[frame=single, stepnumber=3, firstnumber=1, caption={ TLS package ä¸­å¯¹äºnet.Connæ¥å£çš„å®ç°}]{/usr/local/Cellar/go/1.7/libexec/src/crypto/tls/conn.go}

\subsection{signature}
ä¸»è¦æœ‰ä¸¤ç§æ•°å­—ç­¾åç®—æ³• DSA: ä¸€ç§RSA, å¦å¤–ä¸€ç§ECDSA.
å¯¹äºRSA  ç­¾å, ä¼šä½¿ç”¨RSASSA-PKCS1-v1\_5 ç­¾åæœºåˆ¶ï¼Œå…¶ä¸­DigestInfoå¿…é¡»æ˜¯DERç¼–ç çš„.
å¯¹äºDSA ç­¾å, SHA-1 hashçš„20ä¸ªå­—èŠ‚æ˜¯ç›´æ¥é€šè¿‡æ•°å­—ç­¾åç®—æ³•è¿è¡Œå¾—åˆ°ï¼Œä¼šç”Ÿæˆr å’Œ s è¿™ä¸¤ä¸ªå¤§æ•´æ•°.

\subsection{encyption}
å¯¹äº stream cipher encryption, æ˜æ–‡çš„æ¯ä¸€ä¸ªæ¯”ç‰¹ä½éƒ½ä¼šå’Œç”±ä¸€ä¸ªcryptographically secure keyed pseudorandom number generator ç”Ÿæˆçš„æ•°æ®(æ¯”ç‰¹ä½æ•°ä¸æ˜æ–‡çš„ä½æ•°ç›¸åŒ)è¿›è¡Œå¼‚æˆ–.
æ¢å¥è¯è¯´, åºåˆ—å¯†ç æ³•æ˜¯ä¸€ç§æ–‡æœ¬åŠ å¯†æ–¹æ³•ï¼Œå…¶ä¸­ï¼Œåœ¨æ•°æ®æµçš„å„ä¸ªäºŒè¿›åˆ¶æ•°å­—ä¸­åº”ç”¨åŠ å¯†ç§˜é’¥ä»¥åŠç®—æ³•ï¼Œæ¯æ¬¡å¤„ç†ä¸€ä¸ªæ¯”ç‰¹ä½;

å¯¹äº block cipher encryption, å³åˆ†ç»„å¯†ç æ³•, æ˜æ–‡çš„æ¯ä¸€ä¸ªåˆ†ç»„(å—)éƒ½è¢«åŠ å¯†æˆä¸€ä¸ªå¯†æ–‡å—. CBC (Cipher Block Chaining) æ¨¡å¼ä¸­ä¼šå®Œæˆæ‰€æœ‰çš„block cipher encryption, 
è€Œä¸” all items that are block-ciphered will be an exact multiple of the cipher block length.

å¯¹äº AEAD encryption, æ˜æ–‡åœ¨è¢«åŠ å¯†çš„åŒæ—¶ä¿è¯äº†æ˜æ–‡çš„æ•°æ®å®Œæ•´æ€§. è¾“å…¥å¯ä»¥æ˜¯ä»»æ„é•¿åº¦çš„, ç„¶å AEAD-ciphered output é€šå¸¸è¦æ¯”è¾“å…¥çš„é•¿åº¦å¤§ä¸€äº›ï¼Œæ¯•ç«Ÿå®ƒåŠ ä¸Šäº†å®Œæ•´æ€§æ ¡éªŒå€¼.

å¯¹äº public key encryption, ä½¿ç”¨å…¬é’¥ç®—æ³•å¯ä»¥å¯¹æ˜æ–‡è¿›è¡ŒåŠ å¯†, ä½†æ˜¯å¾—åˆ°çš„å¯†æ–‡åªèƒ½è¢«å¯¹åº”çš„ç§˜é’¥è¿›è¡Œè§£å¯†. 
A public-key-encrypted element is encoded as an opague vector $<0..2^{16}-1>$, å…¶ä¸­é•¿åº¦ç”±åŠ å¯†ç®—æ³•å’Œkeyå†³å®š. 

è€Œå¯¹äº RSA encryption, è¿™ä¸ªæ˜¯ä½¿ç”¨ RSAES-PKCS1-v1\_5 encryption scheme å®ç°çš„.

\section{HMAC and the Pseudorandom Function}
ä¸ºäº†ä¿æŠ¤æ¶ˆæ¯çš„å®Œæ•´æ€§, TLS record layer ä½¿ç”¨äº† a keyed Message Authentication Code (MAC). è€Œè¯¥RFCä¸­å®šä¹‰çš„ cipher suites ä½¿ç”¨äº†
HMAC æ¥ç”Ÿæˆ MAC . HMAC æ˜¯åŸºäºå“ˆå¸Œå‡½æ•°çš„.

å¦å¤–, ä¸ºäº†ç”Ÿæˆ key æˆ–è€…è¿›è¡ŒéªŒè¯, éœ€è¦ä½¿ç”¨ construction æ¥å°† secrets æ‰©å±•åˆ°æ•°æ®å—ä¸­ã€‚è¿™ä¸ªä¼ªéšæœºå‡½æ•°(PRF)çš„è¾“å…¥æ˜¯ a secret, a seed, an identifying label,
è¾“å‡ºæ˜¯é•¿åº¦ä¸å›ºå®šçš„æ•°æ®.

ä¸‹é¢å°†åŸºäº HMAC æ¥å®šä¹‰ä¸€ä¸ªä¼ªéšæœºå‡½æ•° PRF, è¯¥å‡½æ•°è¿˜ç»Ÿä¸€ä½¿ç”¨äº†SHA-256å“ˆå¸Œå‡½æ•°. å½“ç„¶ï¼Œä¹Ÿå¯ä»¥é€šè¿‡æ˜ç¡®æŒ‡å‡ºPRFæ¥å®šä¹‰æ–°çš„cipher suitesï¼Œ ä½†æ˜¯è¿™å¾—ç”¨æ¯”SHA-256å®‰å…¨æ€§æ›´é«˜çš„å“ˆå¸Œå‡½æ•°.

é¦–å…ˆï¼Œå®šä¹‰ä¸€ä¸‹P\_hash(secret, data) å‡½æ•°, è¯¥å‡½æ•°æ˜¯ç”¨æ¥æ‰©å¼ æ•°æ®ï¼ˆå…¶å®æ˜¯å¢åŠ è¾“å‡ºçš„MACçš„ä½æ•°çš„), å®ƒä½¿ç”¨ä¸€ä¸ªå‡½æ•°å‡½æ•°æ¥è®²secret å’Œ seed æ‰©å¼ ä¸ºä»»æ„é•¿åº¦çš„è¾“å‡º:
\begin{verbatim}
P_Hash(secret, seed) = HMAC_hash(secret, A(1) + seed) + 
                       HMAC_hash(secret, A(2) + seed) +
                       HMAC_hash(secret, A(3) + seed) + ...
                       
//å…¶ä¸­ï¼Œ A()çš„å®šä¹‰å¦‚ä¸‹:
A(0) = seed
A(1) = HMAC_hash(secret, A(i-1))
\end{verbatim}
å…¶ä¸­ï¼ŒP\_hashå‡½æ•°å¯ä»¥è¢«è°ƒç”¨ä»»æ„æ¬¡æ•°ï¼Œä»è€Œå¯ä»¥ç”Ÿæˆç‰¹å®šé•¿åº¦çš„æ•°æ®. æ¯”å¦‚ï¼ŒP\_Hashä½¿ç”¨äº†SHA256ï¼Œåˆ™å¦‚æœè¦ç”Ÿæˆ80å­—èŠ‚çš„æ•°æ®çš„è¯ï¼Œ
å¾—è¿­ä»£ä¸‰æ¬¡(SHA256ç”Ÿæˆçš„å“ˆå¸Œæ˜¯16å­—èŠ‚ï¼Œ$16 + 32 + 48 = 96$), å¾—åˆ°96å­—èŠ‚çš„æ•°æ®,
ç„¶åå»æ‰æœ«å°¾çš„16å­—èŠ‚, ä¾¿å¯ä»¥å¾—åˆ°80å­—èŠ‚çš„æ•°æ®.
è€ŒTLS ä¸­çš„PRF æ˜¯é€šè¿‡P\_Hash() å‡½æ•°ç”Ÿæˆçš„ï¼Œå¦‚ä¸‹
\begin{verbatim}
//å…¶ä¸­labelæ˜¯ä¸€ä¸ªASCIIç¼–ç çš„å­—ç¬¦ä¸²
PRF(secret, label, seed) = P_[hash](scret, label + seed)
\end{verbatim}

ä¸‹é¢æ˜¯goçš„tlsåŒ…å¯¹äºP\_hashå‡½æ•°çš„å®ç°ï¼Œæ³¨æ„ï¼Œå¢åŠ äº†ä¸€ä¸ªæ–°çš„å‚æ•°hashï¼ŒæŠŠå…¶ä¸­è¦ç”¨åˆ°çš„å“ˆå¸Œå‡½æ•°ä½œä¸ºå‚æ•°ä¼ è¿›æ¥
\begin{lstlisting}[frame=single, stepnumber=5, firstnumber=1, caption={goä¸­å¯¹äºpHashçš„å®ç°}]
// pHash implements the P_hash function, as defined in RFC 4346, section 5.
func pHash(result, secret, seed []byte, hash func() hash.Hash) {
	h := hmac.New(hash, secret)
	h.Write(seed)
	a := h.Sum(nil)

	j := 0
	for j < len(result) {
		h.Reset()
		h.Write(a)
		h.Write(seed)
		b := h.Sum(nil)
		todo := len(b)
		if j+todo > len(result) {
			todo = len(result) - j
		}
		copy(result[j:j+todo], b)
		j += todo

		h.Reset()
		h.Write(a)
		a = h.Sum(nil)
	}
}
\end{lstlisting}

æ¥ä¸‹æ¥æ˜¯å…³äºPRFç®—æ³•çš„, PRFç®—æ³•æ˜¯ç”¨æ¥ä»master secretæ¥ç”Ÿæˆkeysçš„. goçš„tlsåŒ…å¯¹äºPRFå‡½æ•°çš„å®ç°ï¼Œæ€»å…±æœ‰ä¸‰ç§ -- prf10ã€prf12ã€prf30ï¼Œåˆ†åˆ«å¯¹åº”TLS 1.0, TLS 1.2 ä»¥åŠSSL/3.0åè®®,
ä¸‹é¢åªä»‹ç»prf12çš„å®ç°:
\begin{lstlisting}[frame=single, stepnumber=5, firstnumber=1, caption={prf12çš„å®ç°}]
// prf12 implements the TLS 1.2 pseudo-random function, as defined in RFC 5246, section 5.
func prf12(hashFunc func() hash.Hash) func(result, secret, label, seed []byte) {
	return func(result, secret, label, seed []byte) {
		labelAndSeed := make([]byte, len(label)+len(seed))
		copy(labelAndSeed, label)
		copy(labelAndSeed[len(label):], seed)

		pHash(result, secret, labelAndSeed, hashFunc)
	}
}
\end{lstlisting}



ç„¶åè¿™ä¸ªæ˜¯TLSä¸­å¯¹äºHMACçš„ä½¿ç”¨ï¼Œ
\begin{lstlisting}[frame=single, stepnumber=5, firstnumber=1, caption={TLSä¸­Hmacçš„ä½¿ç”¨}]
func (c *Conn) encryptTicket(state *sessionState) ([]byte, error) {
	serialized := state.marshal()
	encrypted := make([]byte, ticketKeyNameLen+aes.BlockSize+len(serialized)+sha256.Size)
	keyName := encrypted[:ticketKeyNameLen]
	iv := encrypted[ticketKeyNameLen : ticketKeyNameLen+aes.BlockSize]
	macBytes := encrypted[len(encrypted)-sha256.Size:]

	if _, err := io.ReadFull(c.config.rand(), iv); err != nil {
		return nil, err
	}
	key := c.config.ticketKeys()[0]
	copy(keyName, key.keyName[:])
	block, err := aes.NewCipher(key.aesKey[:])
	if err != nil {
		return nil, errors.New("tls: failed to create cipher while encrypting ticket: " + err.Error())
	}
	cipher.NewCTR(block, iv).XORKeyStream(encrypted[ticketKeyNameLen+aes.BlockSize:], serialized)

	mac := hmac.New(sha256.New, key.hmacKey[:])
	mac.Write(encrypted[:len(encrypted)-sha256.Size])
	mac.Sum(macBytes[:0])

	return encrypted, nil
}

\end{lstlisting}

ä¸‹é¢æ˜¯crypto/hmacå¯¹äºHMACçš„å®ç°æºç ï¼š
\begin{lstlisting}[frame=single, stepnumber=5, firstnumber=1, caption={Goä¸­Hmacçš„å®ç°}]
type hmac struct {
	size         int
	blocksize    int
	opad, ipad   []byte
	outer, inner hash.Hash
}

func (h *hmac) Sum(in []byte) []byte {
	origLen := len(in)
	in = h.inner.Sum(in)
	h.outer.Reset()
	h.outer.Write(h.opad)
	h.outer.Write(in[origLen:])
	return h.outer.Sum(in[:origLen])
}

func (h *hmac) Write(p []byte) (n int, err error) {
	return h.inner.Write(p)
}

func (h *hmac) Size() int { return h.size }

func (h *hmac) BlockSize() int { return h.blocksize }

func (h *hmac) Reset() {
	h.inner.Reset()
	h.inner.Write(h.ipad)
}

// New returns a new HMAC hash using the given hash.Hash type and key.
func New(h func() hash.Hash, key []byte) hash.Hash {
	hm := new(hmac)
	hm.outer = h()
	hm.inner = h()
	hm.size = hm.inner.Size()
	hm.blocksize = hm.inner.BlockSize()
	hm.ipad = make([]byte, hm.blocksize)
	hm.opad = make([]byte, hm.blocksize)
	if len(key) > hm.blocksize {
		// If key is too big, hash it.
		hm.outer.Write(key)
		key = hm.outer.Sum(nil)
	}
	copy(hm.ipad, key)
	copy(hm.opad, key)
	for i := range hm.ipad {
		hm.ipad[i] ^= 0x36
	}
	for i := range hm.opad {
		hm.opad[i] ^= 0x5c
	}
	hm.inner.Write(hm.ipad)
	return hm
}
\end{lstlisting}


\section{TLS Record Protocol}
TLS Record Protocol æ˜¯ä¸€ä¸ªåˆ†å±‚åè®®ï¼Œåœ¨æ¯ä¸€å±‚ï¼Œæ¶ˆæ¯å¯èƒ½åŒ…å«é•¿åº¦ã€å¤‡æ³¨å’Œå†…å®¹ç­‰ä¿¡æ¯åŸŸã€‚TLS Record Protocol ä¸»è¦è´Ÿè´£æºå¸¦å¾…ä¼ è¾“çš„æ¶ˆæ¯,
å°†æ•°æ®åˆ†æˆåˆ†ç»„ã€å¯èƒ½è¿˜ä¼šå¯¹å…¶è¿›è¡Œå‹ç¼©ã€å¯¹æ•°æ®ç”ŸæˆMACã€åŠ å¯†ã€ç„¶åä¼ è¾“ç»“æœ. åœ¨æ¥æ”¶åˆ°æ•°æ®çš„æ—¶å€™, TLS Record Protocolä¼šè§£å¯†ã€éªŒè¯MACã€è§£å‹ã€
é‡ç»„åˆ†å—ã€ç„¶åå†å‘é€ç»™ä¸Šä¸€çº§çš„clients.

ä½¿ç”¨TLS Record Protocolçš„clientsåªè¦æœ‰å››ç§åè®®: 
\begin{itemize}
    \zihao{-5}
  \item the TLS Handshake protocol
  \item the Alert Protocol
  \item the change cipher spec protocol
  \item the application data protocol
\end{itemize}

\subsection{Connection States}

TLS connection state æ˜¯TLS Record Protocolçš„è¿ä½œç¯å¢ƒ. å®ƒæŒ‡æ˜äº†å‹ç¼©ç®—æ³•ã€åŠ å¯†ç®—æ³•ã€MACç®—æ³•. ä¸‹é¢æ˜¯goçš„tlsåŒ…å…³äºconnection state çš„å®šä¹‰: 
\begin{lstlisting}[frame=single, stepnumber=5, firstnumber=1, caption={Goä¸­connectionçš„å®šä¹‰}]
 // ConnectionState records basic TLS details about the connection.
type ConnectionState struct {
	Version                     uint16     // TLS version used by the connection (e.g. VersionTLS12)
	HandshakeComplete           bool       // TLS handshake is complete
	DidResume                   bool       // connection resumes a previous TLS connection
	CipherSuite                 uint16     // cipher suite in use (TLS_RSA_WITH_RC4_128_SHA, ...)
	NegotiatedProtocol          string     // negotiated next protocol (from Config.NextProtos)
	NegotiatedProtocolIsMutual  bool       // negotiated protocol was advertised by server
	ServerName                  string     // server name requested by client, if any (server side only)
	PeerCertificates            []*x509.Certificate   // certificate chain presented by remote peer
	VerifiedChains              [][]*x509.Certificate // verified chains built from PeerCertificates
	SignedCertificateTimestamps [][]byte   // SCTs from the server, if any
	OCSPResponse                []byte     // stapled OCSP response from server, if any

	// TLSUnique contains the "tls-unique" channel binding value (see RFC
	// 5929, section 3). For resumed sessions this value will be nil
	// because resumption does not include enough context (see
	// https://secure-resumption.com/#channelbindings). This will change in
	// future versions of Go once the TLS master-secret fix has been
	// standardized and implemented.
	TLSUnique []byte
}
\end{lstlisting}

\subsection{å½±å“connection statesçš„å‚æ•° -- æœ¯è¯­}
æ³¨æ„ï¼ŒTLS record layer ä¼šä½¿ç”¨ä¸‹é¢åˆ—å‡ºçš„å®‰å…¨å‚æ•°ç”Ÿæˆ
 client write MAC key, server write MAC key, 
 client write encryption key, server write encryption key, 
 client write IV, server write IV. å¯¹äºclient write å‚æ•°ï¼Œ server åœ¨æ¥æ”¶å’Œå¤„ç†recordsçš„æ—¶å€™ï¼Œä¼šä½¿ç”¨client write è¿™äº›å‚æ•°ï¼Œåä¹‹äº¦ç„¶ã€‚
å½“ä¸‹é¢åˆ—çš„å®‰å…¨å‚æ•°è®¾ç½®å®Œæ¯•ï¼Œå¹¶ä¸”ç”Ÿæˆäº†ç›¸å…³çš„keysä¹‹åï¼Œåˆ™è¿æ¥çŠ¶æ€connection states ä¾¿å¯ä»¥é€šè¿‡è½¬ç§»åˆ°current states è¢«å®ä¾‹åŒ–. 
æ¯ä¸ªè¿æ¥çŠ¶æ€éƒ½ä¼šåŒ…å«å¦‚ä¸‹çš„æ¡ç›®ï¼š
\begin{itemize}
    \zihao{-5}
  \item compression state: å³å‹ç¼©ç®—æ³•çš„å½“å‰çŠ¶æ€
  \item cipher state: åŠ å¯†ç®—æ³•çš„å½“å‰çŠ¶æ€
  \item MAC key: ä½¿ç”¨ä¸Šé¢çš„é‚£äº›å®‰å…¨å‚æ•°ç”Ÿæˆçš„MACç®—æ³•çš„key
  \item sequence number: è¯»å†™çŠ¶æ€å„è‡ªç»´æŠ¤äº†è‡ªå·±çš„sequence number
\end{itemize}
\emph{å®‰å…¨å‚æ•°ï¼š}
\begin{description}
  \item[master secret]A 48-byte secret shared between the two peers in the connection
  \item[client random]A 32-byte value provided by the client
  \item[server random]A 32-byte value provided by the server
  \item[RPF algorithm]An algorithm used to generate keys from the master secret
  \item[bulk encryption algorithm]An algorithm to be used for bulk encryption. å¿…é¡»æŒ‡æ˜ç®—æ³•çš„key size, ä½•ç§cipher (block, stream, or AEAD cipher), 
    cipher æ‰€ä½¿ç”¨çš„block size, the length of explicit and implicit initialization vectors (or nonces)
  \item[MAC algorithm]An algorithm to be used for message authentication. å¿…é¡»è¦æŒ‡æ˜ç®—æ³•æ‰€è¿”å›çš„MACç¢¼çš„å¤§å°
\end{description}


\subsection{Record layer}
The TLS record layer receives uninterpreted data from higher layers in non-empty blocks of arbitrary size.

\subsubsection{Fragmentation}
The record layer fragments informatin blocks into TLSPaintext records carrying data in chunks of $2^14$ bytes or less. 
Client message boundaries are not preserved in the record layer (æ¯”å¦‚, multiple client messages of the same ContentType MAY be
coalesced into a single TLSPlaintext record, or a single message MAY be fragmented across several records).ä¹Ÿå°±æ˜¯è¯´ï¼Œ
å¤šä¸ªç›¸åŒå†…å®¹ç±»å‹çš„client messages å¯èƒ½ä¼šè¢«é‡ç»„æˆä¸€æ¡è®°å½•TLSPlaintext record, ä½†æ˜¯ä¸€æ¡è¿‡å¤§çš„client messageä¹Ÿå¯èƒ½ä¼šè¢«åˆ‡åˆ†æˆå¤šæ¡è®°å½•ã€‚

æ­¤å¤–ï¼Œå€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œç”±äºå†å²åŸå› ï¼ŒTLS1.0ç»§æ‰¿äº†SSL/3.0ï¼Œç‰ˆæœ¬å·å¯èƒ½ä¼šå†™ä½œ3.1, è€ŒTLS1.2å¯¹åº”3.3

\begin{lstlisting}[frame=single, stepnumber=5, firstnumber=1, caption={TLSåè®®ä¸­çš„TLS record ç±»å‹ä»¥åŠhandshake æ¶ˆæ¯ç±»å‹}]
const (
	VersionSSL30 = 0x0300
	VersionTLS10 = 0x0301
	VersionTLS11 = 0x0302
	VersionTLS12 = 0x0303
)

const (
	maxPlaintext    = 16384        // maximum plaintext payload length
	maxCiphertext   = 16384 + 2048 // maximum ciphertext payload length
	recordHeaderLen = 5            // record header length
	maxHandshake    = 65536        // maximum handshake we support (protocol max is 16 MB)

	minVersion = VersionTLS10
	maxVersion = VersionTLS12
)

// TLS record types.
type recordType uint8

const (
	recordTypeChangeCipherSpec recordType = 20
	recordTypeAlert            recordType = 21
	recordTypeHandshake        recordType = 22
	recordTypeApplicationData  recordType = 23
)

// TLS handshake message types.
const (
	typeHelloRequest       uint8 = 0
	typeClientHello        uint8 = 1
	typeServerHello        uint8 = 2
	typeNewSessionTicket   uint8 = 4
	typeCertificate        uint8 = 11
	typeServerKeyExchange  uint8 = 12
	typeCertificateRequest uint8 = 13
	typeServerHelloDone    uint8 = 14
	typeCertificateVerify  uint8 = 15
	typeClientKeyExchange  uint8 = 16
	typeFinished           uint8 = 20
	typeCertificateStatus  uint8 = 22
	typeNextProtocol       uint8 = 67 // Not IANA assigned
)

// TLS compression types.
const (
	compressionNone uint8 = 0
)
\end{lstlisting}

\subsubsection{Record Payload Protection}
recordä¸­æºå¸¦çš„æ•°æ®è¢«å‹ç¼©åï¼Œä¼šç»å† encryption å’Œ MAC functions çš„å¤„ç†. decryption functions ä¼šåè½¬æ­¤è¿‡ç¨‹.
recordä¸­çš„MAC ä¹ŸåŒ…å«äº†ä¸€ä¸ªåºåˆ—å·ï¼Œä»è€Œå¯ä»¥æ£€æµ‹åˆ°æ¶ˆæ¯æ˜¯å¦æ¶ˆå¤±ã€é‡å¤æˆ–è€…æ˜¯é¢å¤–çš„.
ä¸‹é¢æ˜¯recordå†™çš„æºç å®ç°ï¼š


\begin{lstlisting}[frame=single, stepnumber=5, firstnumber=1, caption={TLSåè®®ä¸­å¦‚ä½•å†™record}]
// writeRecordLocked writes a TLS record with the given type and payload to the
// connection and updates the record layer state.
// c.out.Mutex <= L.
func (c *Conn) writeRecordLocked(typ recordType, data []byte) (int, error) {
	b := c.out.newBlock()
	defer c.out.freeBlock(b)

	var n int
	for len(data) > 0 {
		explicitIVLen := 0
		explicitIVIsSeq := false

		var cbc cbcMode
		if c.out.version >= VersionTLS11 {
			var ok bool
			if cbc, ok = c.out.cipher.(cbcMode); ok {
				explicitIVLen = cbc.BlockSize()
			}
		}
		if explicitIVLen == 0 {
			if _, ok := c.out.cipher.(cipher.AEAD); ok {
				explicitIVLen = 8
				// The AES-GCM construction in TLS has an
				// explicit nonce so that the nonce can be
				// random. However, the nonce is only 8 bytes
				// which is too small for a secure, random
				// nonce. Therefore we use the sequence number
				// as the nonce.
				explicitIVIsSeq = true
			}
		}
		m := len(data)
		if maxPayload := c.maxPayloadSizeForWrite(typ, explicitIVLen); m > maxPayload {
			m = maxPayload
		}
		b.resize(recordHeaderLen + explicitIVLen + m)
		b.data[0] = byte(typ)
		vers := c.vers
		if vers == 0 {
			// Some TLS servers fail if the record version is
			// greater than TLS 1.0 for the initial ClientHello.
			vers = VersionTLS10
		}
		b.data[1] = byte(vers >> 8)
		b.data[2] = byte(vers)
		b.data[3] = byte(m >> 8)
		b.data[4] = byte(m)
		if explicitIVLen > 0 {
			explicitIV := b.data[recordHeaderLen : recordHeaderLen+explicitIVLen]
			if explicitIVIsSeq {
				copy(explicitIV, c.out.seq[:])
			} else {
				if _, err := io.ReadFull(c.config.rand(), explicitIV); err != nil {
					return n, err
				}
			}
		}
		copy(b.data[recordHeaderLen+explicitIVLen:], data)
		c.out.encrypt(b, explicitIVLen)
		if _, err := c.write(b.data); err != nil {
			return n, err
		}
		n += m
		data = data[m:]
	}

	if typ == recordTypeChangeCipherSpec {
		if err := c.out.changeCipherSpec(); err != nil {
			return n, c.sendAlertLocked(err.(alert))
		}
	}

	return n, nil
}
\end{lstlisting}

\paragraph{Null or Standard Stream Cipher}

æ³¨æ„MACæ˜¯åœ¨åŠ å¯†å‰è®¡ç®—å¾—åˆ°çš„ï¼Œstream ciphter åŠ å¯†äº†åŒ…å«MACçš„entire block.

\paragraph{CBC Block Cipher}

å¯¹äºåˆ†ç»„åŠ å¯†ï¼ˆæ¯”å¦‚3DESã€AESï¼‰, 

\subparagraph{IV}
The Initialization Vector (IV) SHOULD be chosen at random, and MUST be unpredictable. Note that in versions of TLS prior to 1.1,
there was no IV field, and the last ciphertext block of the previous reord (the ``CBC residue'') was used a the IV. This was 
changed to prevent the attacts described in CBCATT. For block ciphers, the IV length is of length ç­‰äºå®‰å…¨å‚æ•°ä¸­çš„ \begin{verbatim} record_iv_lenghth \end{verbatim},
äº¦ç­‰äº\begin{verbatim} block_size \end{verbatim}

\end{document}


\end{document}
